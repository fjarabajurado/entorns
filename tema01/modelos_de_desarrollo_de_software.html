<!doctype html>
<html lang="ca">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>Modelos de desarrollo de software | tema01 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="Fran Jaraba" />
<link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/4.0/" />
<meta name="generator" content="eXeLearning 2.8.1 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-5"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Omet navegació</a></p>
<header id="header" ><div id="headerContent">tema01</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Unitat Didàctica</a></li>
   <li class="current-page-parent"><a href="desarrollo_de_software.html" class="current-page-parent daddy">Desarrollo de Software</a>
   <ul>
      <li><a href="concepto_de_programa.html" class="no-ch">Concepto de programa</a></li>
      <li><a href="cdigo_fuente_objeto_y_ejecutable.html" class="no-ch">Código Fuente, Objeto y Ejecutable</a></li>
      <li><a href="mquina_virtual.html" class="no-ch">Máquina virtual</a></li>
      <li><a href="lenguajes_de_programacin.html" class="daddy">Lenguajes de programación</a>
      <ul class="other-section">
         <li><a href="caractersticas_de_los_lenguajes_ms_difundidos.html" class="no-ch">Características de los lenguajes más difundidos</a></li>
      </ul>
      </li>
      <li class="current-page-parent"><a href="fases_del_desarrollo_de_una_aplicacin.html" class="current-page-parent daddy">Fases del desarrollo de una aplicación</a>
      <ul>
         <li id="active"><a href="modelos_de_desarrollo_de_software.html" class="active no-ch">Modelos de desarrollo de software</a></li>
      </ul>
      </li>
      <li><a href="estructuras_de_equipos_de_trabajo_para_el_desarrollo_y_revisin_de_programas_informticos.html" class="no-ch">Estructuras de equipos de trabajo para el desarrollo y revisión de programas informáticos</a></li>
      <li><a href="obtencin_de_cdigo_ejecutable_herramientas.html" class="no-ch">Obtención de código ejecutable. Herramientas</a></li>
   </ul>
   </li>
   <li><a href="desenvolupament_de_software.html" class="no-ch">Desenvolupament de Software</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="fases_del_desarrollo_de_una_aplicacin.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="estructuras_de_equipos_de_trabajo_para_el_desarrollo_y_revisin_de_programas_informticos.html" class="next"><span>Següent<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">Modelos de desarrollo de software</h1></header>
<article class="iDevice_wrapper textIdevice" id="id7">
<div class="iDevice emphasis0" >
<div id="ta7_120_2" class="block iDevice_content">
<div class="exe-text"><p>Se puede definir el <strong>ciclo de vida de un proyecto</strong> (<em>ciclo de vida del software</em>) como: <span style="color: #008080;">conjunto de fases o etapas, procesos y actividades requeridas para ofertar, desarrollar, probar, integrar, explotar y mantener un producto software</span>.</p>
<p><strong>Al principio</strong>, el desarrollo de una aplicación era un <strong>proceso individualizado</strong>, carente de planificación donde únicamente se hacía una <strong>codificación</strong> y <strong>prueba/depuración</strong> <strong>del código</strong> a desarrollar. Pero pronto se detectaron <strong>muchos inconvenientes</strong>:</p>
<ul>
<li>Dependencia total de la persona que programó.</li>
<li>Se desconoce el progreso y la calidad del proyecto.</li>
<li>Falta de flexibilidad ante cambios.</li>
<li>Posible incremento del coste o incluso imposibilidad de completarlo.</li>
<li>Puede no reflejar las necesidades del cliente.</li>
</ul>
<p>De ahí surgió la necesidad de hacer <strong>desarrollos más estructurados</strong>, <strong>aportando</strong> <strong>valor añadido y calidad</strong> al producto final, apareciendo el concepto de ciclo de vida del software.</p>
<p>Algunas <strong>ventajas</strong> que se consiguen son:</p>
<ul>
<li>En las primeras fases, aunque no haya líneas de código, <strong>invertir en pensar el diseño es avanzar en la construcción del sistema</strong>, pues facilitará la codificación.</li>
<li>Asegura un <strong>desarrollo progresivo</strong>, con <strong>controles sistemáticos</strong>, que permite <strong>detectar defectos</strong> con mucha <strong>antelación</strong>.</li>
<li>El seguimiento del proceso permite <strong>controlar los plazos</strong> de entrega retrasados y los costes excesivos.</li>
<li>La <strong>documentación</strong> se realiza de manera formal y estandarizada <strong>simultáneamente al desarrollo</strong>, lo que <strong>facilita la comunicación interna</strong> entre el equipo de desarrollo y la de éste con los usuarios.</li>
<li><strong>Aumenta</strong> la <strong>visibilidad</strong> y la posibilidad de <strong>control</strong> para la gestión del proyecto.</li>
<li>Supone una <strong>guía para el personal de desarrollo</strong>, marcando las tareas a realizar en cada momento.</li>
<li><strong>Minimiza la necesidad de rehacer trabajo</strong> y los problemas de puesta a punto.</li>
</ul>
<p>Diversos autores han planteado distintos modelos de ciclos de vida, pero los más conocidos y utilizados son los citados a continuación:</p>
<p></p>
<p></p>
<p></p></div>
</div>
</div>
</article>
<article class="iDevice_wrapper textIdevice em_iDevice" id="id10">
<div class="iDevice emphasis1" >
<header class="iDevice_header iDevice_header_noIcon"><h1 class="iDeviceTitle">Modelos de Proceso Prescriptivo</h1></header>
<div class="iDevice_inner">
<div class="iDevice_content_wrapper">
<div id="ta10_120_2" class="block iDevice_content">
<div class="exe-text"><p>Los modelos de proceso prescriptivo fueron propuestos originalmente para poner orden en el caos del desarrollo de software. La historia indica que estos modelos tradicionales han dado cierta estructura útil al trabajo de ingeniería de software y que constituyen un mapa razonablemente eficaz para los equipos de software. Sin embargo, el trabajo de ingeniería de software y el producto que genera siguen “al borde del caos”.</p>
<h2>Modelo en Cascada ( <em>waterfall model</em> )</h2>
<p>Es un procedimiento lineal que se caracteriza por dividir los procesos de desarrollo en <strong>sucesivas fases de proyecto</strong>, donde  cada una de estas fases <strong>se ejecuta tan solo una vez</strong>. Los resultados de cada una de las fases sirven como hipótesis de partida para la siguiente. Este escaso margen de error lo hace prácticamente imposible de utilizar. Sólo es aplicable en pequeños desarrollos.</p>
<p style="text-align: center;"><img src="des_soft_06.png" alt="" width="688" height="400" /></p>
<p>El modelo de la cascada es el paradigma más antiguo de la ingeniería de software. Entre los problemas que en ocasiones surgen al aplicar el modelo de la cascada se encuentran los siguientes:</p>
<ol>
<li>Es <strong>raro</strong> que los <strong>proyectos reales</strong> <strong>sigan el flujo secuencial</strong> propuesto por el modelo. Aunque el modelo lineal acepta repeticiones, lo hace en forma indirecta.</li>
<li>A menudo, es <strong>difícil para el cliente enunciar en forma explícita todos los requerimientos</strong>. El modelo de la cascada necesita que se haga y tiene <strong>dificultades</strong> para aceptar la <strong>incertidumbre</strong> natural que existe <strong>al principio de muchos proyectos</strong>.</li>
<li>El <strong>cliente</strong> debe tener <strong>paciencia</strong>. No se dispondrá de una versión funcional del(de los) programa(s) hasta que el proyecto esté muy avanzado. Un error grande sería desastroso si se detectara al revisar el programa en funcionamiento.</li>
</ol>
<p>En un análisis de proyectos reales se detectó que el modelo en cascada suele llegar a "estados de bloqueo” en los que ciertos miembros del equipo de proyecto deben esperar a otros a fin de terminar tareas interdependientes.</p>
<h2>Modelos de proceso incremental</h2>
<p>Hay situaciones en las que el esfuerzo de desarrollo imposibilita un proceso lineal. Además, tal vez haya una <strong>necesidad imperiosa de dar rápidamente cierta funcionalidad</strong> limitada de software a los usuarios y <strong>aumentarla</strong> en las <strong>entregas posteriores</strong> de software. En tales casos, se elige un modelo de proceso diseñado para <strong>producir el software en incrementos</strong>.</p>
<p>El modelo de proceso incremental se centra en que en cada incremento se entrega un producto que ya opera. Los primeros incrementos son versiones desnudas del producto final, pero<br />proporcionan capacidad que sirve al usuario y también le dan una plataforma de evaluación. Por ejemplo, un software para procesar textos que se elabore con el paradigma incremental quizá entregue en el primer incremento las funciones básicas de administración de archivos, edición y producción del documento; en el segundo dará herramientas más sofisticadas de edición y producción de documentos; en el tercero habrá separación de palabras y revisión de la ortografía; y en el cuarto se proporcionará la capacidad para dar formato avanzado a las páginas.</p>
<p>Cuando se utiliza un modelo incremental, es frecuente que el primer incremento sea el producto fundamental. Es decir, se abordan los requerimientos básicos, pero no se proporcionan muchas características suplementarias (<em>algunas conocidas y otras no</em>). El cliente usa el producto fundamental (<em>o lo somete a una evaluación detallada</em>).</p>
<p style="text-align: center;"><img src="des_soft_11.png" alt="" width="560" height="311" /></p>
<h2>Modelos de proceso evolutivo</h2>
<p>El software, como todos los sistemas complejos, evoluciona en el tiempo. Es frecuente que los requerimientos del negocio y del producto cambien conforme avanza el desarrollo, lo que hace que no sea realista trazar una trayectoria rectilínea hacia el producto final; los plazos apretados del mercado hacen que sea imposible la terminación de un software perfecto, pero debe lanzarse una versión limitada a fin de aliviar la presión de la competencia o del negocio; se comprende bien el conjunto de requerimientos o el producto básico, pero los detalles del producto o extensiones del sistema aún están por definirse.</p>
<p>En estas situaciones y otras parecidas se necesita un modelo de proceso diseñado explícitamente para adaptarse a un producto que evoluciona con el tiempo. Los modelos evolutivos son iterativos. Se caracterizan por la manera en la que permiten desarrollar versiones cada vez más completas del software. Dos modelos comunes de proceso evolutivo son:</p>
<h3>Modelo prototipos.</h3>
<p style="padding-left: 30px;"><img src="des_soft_08.png" alt="" style="float: right; margin-right: 20px; margin-left: 20px;" width="432" height="421" />Es frecuente que un cliente tenga unas nociones generales pero no identifique los requerimientos detallados. En otros casos, el desarrollador tal vez no esté seguro de la eficiencia de un algoritmo, de la adaptabilidad de un sistema operativo o de la forma que debe adoptar la interacción entre el humano y la máquina. En estas situaciones,el paradigma de hacer prototipos tal vez ofrezca el mejor enfoque.</p>
<p style="padding-left: 30px;">Este paradigma ayuda a mejorar la comprensión de lo que hay que elaborar cuando los requerimientos no están claros.  </p>
<p style="padding-left: 30px;">Ccomienza con comunicación. Reuniones con otros participantes para definir los objetivos generales del software e identificar requerimientos . Se planea rápidamente una iteración para hacer el prototipo, y se lleva a cabo el modelado (<em>en forma de un “diseño rápido”</em>). Éste se centra en la representación de aquellos aspectos del software que serán visibles para los usuarios finales (<em>por ejemplo, disposición de</em><br /><em>la interfaz humana o formatos de la pantalla de salida</em>). El diseño rápido lleva a la construcción<br />de un prototipo. Éste se entrega y es evaluado por los participantes, que dan retroalimentación para mejorar los requerimientos. La iteración ocurre a medida de que el prototipo es afinado para satisfacer las necesidades de distintos participantes, y al mismo tiempo permita entender mejor lo que se necesita hacer.</p>
<p style="padding-left: 30px;">La idea es que el prototipo sirva como mecanismo para identificar los requerimientos del software. Para la construcción del primer prototivo pueden utilizarse fragmentos de programas existentes o aplicar herramientas que permitan generar rápidamente programas que funcionen.</p>
<h3>Modelo Espiral</h3>
<p style="padding-left: 30px;">Es un <strong>modelo evolutivo</strong> del proceso del software y <strong>se acopla</strong> con la naturaleza iterativa de hacer <strong>prototipos</strong> con los aspectos del modelo de <strong>cascada</strong>. Tiene el potencial para hacer un <strong>desarrollo rápido de versiones cada vez más completas</strong>.</p>
<p style="padding-left: 30px;">El software se desarrolla en una serie de entregas evolutivas. Durante las primeras iteraciones, lo que se entrega puede ser un modelo o prototipo. En las iteraciones posteriores se producen versiones cada vez más completas.</p>
<p style="padding-left: 30px;">El costo y la programación de actividades se ajustan con base en la retroalimentación obtenida del cliente después de la entrega. A diferencia de otros modelos del proceso que finalizan cuando se entrega el software, el modelo espiral puede adaptarse para aplicarse a lo largo de toda la vida del software. El modelo espiral es un enfoque realista para el desarrollo de sistemas y de software a gran escala. El modelo espiral usa los prototipos como mecanismo de reducción de riesgos, pero, más importante, permite aplicar el enfoque de hacer prototipos en cualquier etapa de la evolución del producto.</p>
<p style="padding-left: 30px; text-align: center;"><img src="des_soft_07.png" alt="" width="736" height="421" /></p>
<h2>Modelos concurrentes</h2>
<p style="padding-left: 30px;"><img src="des_soft_12.png" alt="" style="float: right; margin-right: 20px; margin-left: 20px;" width="446" height="584" />Permite que un equipo de software divida el desarrollo del software en elementos iterativos y concurrentes  Por ejemplo, la <strong>actividad de modelado</strong> definida para el modelo espiral se logra por medio de invocar una o más de las siguientes acciones de software: <strong>hacer prototipos, análisis y diseño</strong>.</p>
<p style="padding-left: 30px;">Cada actividad puede encontrarse en uno de los momentos que se muestran en la imagen (<em>en desarrollo, cambios en espera, en evaluación, en revisión o terminada</em>). En forma similar, es posible representar de manera análoga otras actividades, acciones o tareas (<em>por ejemplo, comunicación o construcción</em>). Todas las actividades de ingeniería de software existen de manera concurrente, pero se hallan en diferentes estados.</p>
<p style="padding-left: 30px;">Por ejemplo, la <strong>actividad de comunicación</strong> termina su primera iteración al principio de un proyecto y existe en el estado de cambios en espera. La <strong>actividad de modelado</strong> (<em>que existía en estado inactivo mientras concluía la comunicación inicial</em>), ahora hace una transición al estado en desarrollo. Sin embargo, si el cliente indica que deben hacerse cambios en los requerimientos, la actividad de modelado pasa del estado en desarrollo al de<br />cambios en espera.</p>
<p style="padding-left: 30px;">El modelado concurrente define una serie de <strong>eventos</strong> que <strong>desencadenan transiciones de un estado a otro</strong> para cada una de las actividades, acciones o tareas de la ingeniería de software. Por ejemplo, durante las primeras etapas del diseño (<em>acción importante de la ingeniería de software que ocurre durante la actividad de modelado</em>), no se detecta una inconsistencia en el modelo de requerimientos. Esto genera el evento corrección del modelo de análisis, que disparará la acción de análisis de requerimientos del estado terminado al de cambios en espera.</p>
<p style="padding-left: 30px;"><strong>Ventajas</strong>:</p>
<ul>
<li>Excelente para proyectos en los que se conforman grupos de trabajo independientes.</li>
<li>Proporciona una imagen exacta del estado actual de un proyecto.</li>
</ul>
<p style="padding-left: 30px;"><strong>Desventajas</strong></p>
<ul>
<li>Si no se dan las condiciones señaladas no es aplicable.</li>
<li>Si no existen grupos de trabajo no se puede trabajar en este método</li>
</ul>
<p style="padding-left: 30px;"></p>
<p style="padding-left: 30px;"></p>
<p></p>
<p></p>
<p></p></div>
</div>
</div>
</div>
</div>
</article>
<article class="iDevice_wrapper textIdevice em_iDevice" id="id11">
<div class="iDevice emphasis1" >
<header class="iDevice_header iDevice_header_noIcon"><h1 class="iDeviceTitle">Desarrollo Ágil</h1></header>
<div class="iDevice_inner">
<div class="iDevice_content_wrapper">
<div id="ta11_121_2" class="block iDevice_content">
<div class="exe-text"><p>En 2001, notables desarrolladores de software, escritores y consultores(<em>grupo conocido como la “<strong>Alianza Ágil</strong>”</em>) firmaron el “<em>Manifiesto por el desa</em><em>rrollo ágil de software</em>”. En él se establecía lo siguiente:</p>
<p style="padding-left: 30px;"><span style="font-family: georgia, palatino, serif;">Estamos descubriendo formas mejores de desarrollar software, por medio de hacerlo y de dar ayuda a otros para que lo hagan. Ese trabajo nos ha hecho valorar:</span></p>
<ul>
<li><span style="font-family: georgia, palatino, serif;">Los individuos y sus interacciones, sobre los procesos y las herramientas</span></li>
<li><span style="font-family: georgia, palatino, serif;">El software que funciona, más que la documentación exhaustiva</span></li>
<li><span style="font-family: georgia, palatino, serif;">La colaboración con el cliente, y no tanto la negociación del contrato</span></li>
<li><span style="font-family: georgia, palatino, serif;">Responder al cambio, mejor que apegarse a un plan</span></li>
</ul>
<p>Los métodos ágiles se desarrollaron como un esfuerzo por superar las debilidades reales y percibidas de la ingeniería de software convencional. La agilidad es algo más que una respuesta efectiva al cambio. También incluye estructuras de equipo y actitudes que hacen más fácil la comunicación (<em>entre los miembros del equipo, tecnólogos y gente de negocios, entre los ingenieros de software y sus gerentes, etc</em>.); pone el énfasis en la entrega rápida de software funcional y resta importancia a los productos intermedios del trabajo (<em>lo que no siempre es bueno</em>); adopta al cliente como parte del equipo de desarrollo y trabaja para eliminar la actitud de “nosotros y ellos” que todavía invade muchos proyectos de software.</p>
<p>Los métodos de desarrollo ágil hacen el <strong>seguimiento constante</strong> y la <strong>realización</strong> de diversas <strong>pruebas</strong> y pequeños <strong>ajustes</strong> en <strong>proyectos</strong> que necesitan agilidad o que están en <strong>constante cambio</strong>.</p>
<h2>Programación Extrema (XP)</h2>
<p>Es el enfoque más utilizado del desarrollo de software ágil. Se trata de una metodología cuyo <strong>objetivo</strong> es <strong>crear sistemas de alta calidad</strong>, basados en una <strong>estrecha interacción con los clientes</strong>, <strong>pruebas constantes</strong> y <strong>ciclos de desarrollo cortos</strong>.Define un conjunto de <strong>cinco valores</strong> que establecen el fundamento para todo trabajo: <strong>comunicación</strong>, <strong>simplicidad</strong>, <strong>retroalimentación</strong>, <strong>valentía</strong> y <strong>respeto</strong>. Cada uno de estos valores se usa como un motor para actividades, acciones y tareas específicas de XP.</p>
<p>El software se desarrolla en ciclos semanales, con reuniones periódicas entre el cliente y el equipo de desarrollo. Algunos de los elementos que forman parte del desarrollo extremo son:</p>
<ul>
<li><strong>Juego de planificación</strong>: reunión al principio de la semana con el cliente para enumerar las funcionalidades prioritarias y aclarar las expectativas y necesidades con respecto al proyecto.</li>
<li><strong>Cliente siempre disponible</strong>: disponibilidad constante del cliente para responder a preguntas, priorizar el alcance y realizar cambios.</li>
<li>Lanzamientos pequeños o entregas cortas: al <strong>final de la semana</strong> el cliente recibe <strong>pequeñas versiones</strong> del proyecto para que pueda <strong>probarlo y sugerir mejoras</strong>.</li>
<li><strong>Metáfora</strong>: estrategia utilizada para facilitar la comunicación con el cliente, traduciendo las particularidades del sistema a su realidad. </li>
<li><strong>Diseño sencillo</strong>: la simplicidad debe centrarse en el resultado.</li>
<li><strong>Pruebas de usuario</strong>: es el momento en que el cliente y los analistas prueban las entregas.</li>
<li><strong>Ritmo sostenible</strong>: los ciclos deben estar formados por semanas de hasta 40 horas, con un ritmo de trabajo saludable por parte del equipo.</li>
<li><strong>Propiedad colectiva</strong>: los proyectos desarrollados deben ser conocidos y accesibles a todo el equipo.</li>
<li><strong>Programación por parejas</strong>: la programación en un mismo ordenador se realiza por parejas para garantizar que el desarrollo pase por una revisión constante y el aprendizaje de cada profesional evolucione en el proceso.</li>
<li><strong>Estandarización del código</strong>: es necesario estandarizar el código para que todo el mundo siga las mismas reglas.</li>
<li><strong>Desarrollo dirigido por pruebas</strong>: las pruebas unitarias son fundamentales para la calidad del proyecto.</li>
<li><strong>Refactoring</strong>: es un proceso que permite la mejora continua del proyecto, haciéndolo más claro, con menos posibilidad de errores y duplicación de procesos.</li>
<li><strong>Integración continua</strong>: al crear una nueva funcionalidad, ésta debe integrarse rápidamente a la versión actual del sistema. </li>
</ul>
<p>La programación extrema usa un <strong>enfoque orientado a objetos</strong> y engloba un conjunto de reglas y prácticas agrupadas en cuatro actividades estructurales: <strong>planeación</strong>, <strong>diseño</strong>, <strong>codificación</strong> y <strong>pruebas</strong>.</p>
<ul>
<li>Planeación. comienza escuchando para recabar requerimientos y crear “historias” que describen la salida necesaria, características y funcionalidad del software que se va a elaborar.</li>
<li>Diseño. sigue rigurosamente el principio MS (<em>mantenlo sencillo</em>). El diseño guía la implementación de una historia conforme se escribe: nada más y nada menos. Se usan las tarjetas CRC (<em>Clase-Responsabilidad-Colaborador</em>) identifican y organizan las clases orientadas a objetos que son relevantes para el desarrollo de software. El diseño es visto como un artefacto en transición que puede y debe modificarse continuamente a medida que avanza la construcción. El diseño ocurre tanto antes como después de que comienza la codificación. </li>
<li>Codificación. Después de que las historias han sido desarrolladas y de que se ha hecho el trabajo de diseño preliminar, el equipo no inicia la codificación, sino que desarrolla una serie de<br /><strong>pruebas unitarias</strong> a cada una de las historias que se van a incluir en la entrega. Una vez creada la prueba unitaria,  el desarrollador está mejor capacitado para centrarse en lo que debe implementarse para pasar la prueba.  Una vez que el código está terminado, se le aplica de inmediato una prueba unitaria, con lo que se obtiene retroalimentación instantánea para los desarrolladores.</li>
<li>Pruebas. Las pruebas unitarias que se crean deben implementarse con el uso de una estructura que permita automatizarlas. A medida que se organizan las pruebas unitarias individuales en un “grupo de prueba universal” [Wel99], las pruebas de la integración y validación del sistema pueden efectuarse a diario. </li>
</ul>
<p><img src="des_soft_13.png" alt="" width="545" height="413" /><br /><br /></p>
<h2>Modelo Scrum</h2>
<p>Es un <strong>proceso para llevar a cabo un conjunto de tareas de forma regular</strong> con el <strong>objetivo</strong> principal de <strong>trabajar de manera colaborativa</strong>, es decir, para fomentar el trabajo en equipo. Se otorga un gran valor al intelecto, la experiencia y las habilidades que los miembros del equipo de desarrollo aportan.</p>
<p>Incorpora las siguientes actividades estructurales: <strong>requerimientos</strong>, <strong>análisis</strong>, <strong>diseño</strong>, <strong>evolución</strong> y <strong>entrega</strong>. Dentro de cada actividad estructural, las tareas del trabajo ocurren con un patrón del proceso llamado <strong>Sprint</strong>. El trabajo realizado dentro de un sprint se adapta al problema en cuestión y se define en tiempo real por parte del equipo Scrum. </p>
<p>El proceso de trabajo en Scrum se organiza de la siguiente manera:</p>
<ul>
<li><strong>Organización del trabajo pendiente</strong>: el Scrum Master identifica el trabajo que debe realizarse y lo documenta en un lugar centralizado, como una herramienta de gestión de proyectos.</li>
<li><strong>Planificación del sprint</strong>: se realiza una <strong>sesión de planificación</strong> del sprint para determinar en qué se enfocará el equipo durante ese periodo específico. Se evalúa el trabajo pendiente y se establecen los objetivos del sprint.</li>
<li><strong>Ejecución del sprint</strong>: el equipo trabaja en las tareas definidas. El sprint tiene una duración típica de dos semanas, pero puede ser más corto o largo según las necesidades del equipo.</li>
<li><strong>Reunión diaria de seguimiento</strong>: con duración máxima de 15 minutos. En ella, el equipo se actualiza sobre el trabajo realizado, identifica obstáculos y planifica las próximas tareas.</li>
<li><strong>Revisión del sprint</strong>: al finalizar el sprint, se realiza una <strong>reunión de revisión</strong>. Durante esta reunión, se presenta el trabajo completado durante el sprint para su aprobación o inspección, principalmente por parte de los usuarios o clientes. Si el trabajo no cumple con los requisitos, el sprint no se considera concluido y se deben tomar acciones para resolverlo antes de pasar al siguiente sprint.</li>
<li><strong>Retroalimentación del sprint</strong>: Después de cada sprint, se lleva a cabo una retrospectiva para analizar cómo se desarrolló el sprint y qué se puede mejorar en el futuro. Se identifican las prácticas que fueron beneficiosas y se definen acciones para optimizar el proceso en próximos sprints.</li>
</ul>
<p style="text-align: center;"><img src="des_soft_09.png" alt="" width="768" height="435" /></p>
<p></p></div>
</div>
</div>
</div>
</div>
</article>
<div id="packageLicense" class="cc cc-by-sa">
<p><span>Llicenciat sota la </span> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Llicència Creative Commons Reconeixement CompartirIgual 4.0</a></p>
</div>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="fases_del_desarrollo_de_una_aplicacin.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="estructuras_de_equipos_de_trabajo_para_el_desarrollo_y_revisin_de_programas_informticos.html" class="next"><span>Següent<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<p id="made-with-eXe"><a href="https://exelearning.net/" target="_blank" rel="noopener"><span>Creat amb eXeLearning<span> (Finestra nova)</span></span></a></p><script type="text/javascript" src="_style_js.js"></script></body></html>